<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.42">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="dcterms.date" content="2025-03-31">
<meta name="description" content="Some thoughts on features that could make programming languages more powerful">

<title>Write Simpler Code: Letting the Runtime Handle Incrementality, State, and Speculation – Arjun Srivastava</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<link href="../../favicon.ico" rel="icon">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-2f5df379a58b258e96c21c0638c20c03.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-text-highlighting-styles">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-dark-b53751a350365c71b6c909e95f209ed1.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap-d75320580429fd03ccc14abf5aea7e44.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme" id="quarto-bootstrap" data-mode="light">
<link href="../../site_libs/bootstrap/bootstrap-dark-03cff2e87a80ce85282700c0d3d2a4d3.min.css" rel="prefetch" append-hash="true" class="quarto-color-scheme quarto-color-alternate" id="quarto-bootstrap" data-mode="dark">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

<script type="text/javascript">

(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
ga('create', 'UA-101184475-1', 'auto');

ga('send', {
  hitType: 'pageview',
  'anonymizeIp': true,
});
</script>


<meta property="og:title" content="Write Simpler Code: Letting the Runtime Handle Incrementality, State, and Speculation – Arjun Srivastava">
<meta property="og:description" content="Some thoughts on features that could make programming languages more powerful">
<meta property="og:site_name" content="Arjun Srivastava">
<meta name="twitter:title" content="Write Simpler Code: Letting the Runtime Handle Incrementality, State, and Speculation – Arjun Srivastava">
<meta name="twitter:description" content="Some thoughts on features that could make programming languages more powerful">
<meta name="twitter:card" content="summary">
</head>

<body class="floating nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top quarto-banner">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">Arjun Srivastava</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../podcast"> 
<span class="menu-text">Podcast</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../posts"> 
<span class="menu-text">Thoughts</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="https://arjunsriva.com/library"> 
<span class="menu-text">Library</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../about.html"> 
<span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://twitter.com/arjunsriv"> <i class="bi bi-twitter" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="../../index.xml"> <i class="bi bi-rss" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
  <a href="" class="quarto-color-scheme-toggle quarto-navigation-tool  px-1" onclick="window.quartoToggleColorScheme(); return false;" title="Toggle dark mode"><i class="bi"></i></a>
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default toc-left page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">Write Simpler Code: Letting the Runtime Handle Incrementality, State, and Speculation</h1>
                  <div>
        <div class="description">
          Some thoughts on features that could make programming languages more powerful
        </div>
      </div>
                          <div class="quarto-categories">
                <div class="quarto-category">Future</div>
                <div class="quarto-category">Idea</div>
                <div class="quarto-category">WIP</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta">

      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">March 31, 2025</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#incrementality" id="toc-incrementality" class="nav-link active" data-scroll-target="#incrementality">1. Incrementality</a>
  <ul class="collapse">
  <li><a href="#the-problem" id="toc-the-problem" class="nav-link" data-scroll-target="#the-problem">The Problem</a></li>
  <li><a href="#the-solution" id="toc-the-solution" class="nav-link" data-scroll-target="#the-solution">The Solution</a></li>
  </ul></li>
  <li><a href="#auto-backward-differentiation" id="toc-auto-backward-differentiation" class="nav-link" data-scroll-target="#auto-backward-differentiation">2. Auto Backward Differentiation</a>
  <ul class="collapse">
  <li><a href="#the-concept" id="toc-the-concept" class="nav-link" data-scroll-target="#the-concept">The Concept</a></li>
  </ul></li>
  <li><a href="#auto-reversibility" id="toc-auto-reversibility" class="nav-link" data-scroll-target="#auto-reversibility">3. Auto Reversibility</a>
  <ul class="collapse">
  <li><a href="#the-idea" id="toc-the-idea" class="nav-link" data-scroll-target="#the-idea">The Idea</a></li>
  </ul></li>
  <li><a href="#speculative-execution" id="toc-speculative-execution" class="nav-link" data-scroll-target="#speculative-execution">4. Speculative Execution</a>
  <ul class="collapse">
  <li><a href="#the-concept-1" id="toc-the-concept-1" class="nav-link" data-scroll-target="#the-concept-1">The Concept</a></li>
  </ul></li>
  <li><a href="#external-state-management" id="toc-external-state-management" class="nav-link" data-scroll-target="#external-state-management">5. External State Management</a>
  <ul class="collapse">
  <li><a href="#the-challenge" id="toc-the-challenge" class="nav-link" data-scroll-target="#the-challenge">The Challenge</a></li>
  <li><a href="#the-solution-1" id="toc-the-solution-1" class="nav-link" data-scroll-target="#the-solution-1">The Solution</a></li>
  </ul></li>
  <li><a href="#a-unified-system" id="toc-a-unified-system" class="nav-link" data-scroll-target="#a-unified-system">A Unified System</a></li>
  <li><a href="#philosophy-and-design-challenges" id="toc-philosophy-and-design-challenges" class="nav-link" data-scroll-target="#philosophy-and-design-challenges">Philosophy and Design Challenges</a></li>
  <li><a href="#conclusion" id="toc-conclusion" class="nav-link" data-scroll-target="#conclusion">Conclusion</a></li>
  </ul>
</nav>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar zindex-bottom">
    </div>
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">





<p>I’m sharing these ideas as concepts I’d be excited to see programming languages explore. They represent different ways to push implementation details into the language or runtime, allowing developers to focus more on intent rather than mechanics.</p>
<section id="incrementality" class="level2">
<h2 class="anchored" data-anchor-id="incrementality">1. Incrementality</h2>
<section id="the-problem" class="level3">
<h3 class="anchored" data-anchor-id="the-problem">The Problem</h3>
<p>When a small input to a large function changes, we typically recompute everything. This is inefficient and wastes computational resources.</p>
</section>
<section id="the-solution" class="level3">
<h3 class="anchored" data-anchor-id="the-solution">The Solution</h3>
<p>Incrementality allows us to track dependencies and only recompute what’s necessary.</p>
<p>In UI frameworks like React, incrementality means only re-rendering components affected by state changes. In database systems, it means only recomputing affected query results. As a language feature, this would mean automatically tracking dependencies between data and derived values across your entire program, eliminating manual optimization work.</p>
<p>Imagine writing code that declaratively describes a transformation (like server state → UI state), and having the runtime automatically ensure they stay in sync, computing only what changed.</p>
<p>Consider a concrete backend example: an API endpoint that returns a list of 100 serialized objects as JSON. Currently, when a single object changes, we typically serialize the entire collection again. With incrementality as a language feature, the system would automatically detect which objects changed and only re-serialize those specific objects, significantly reducing computational overhead for frequently accessed endpoints.</p>
<p>While frontend frameworks like Svelte already implement this idea, it should become a core feature for backend systems too. Caches and indexes are perfect examples of derived states (data that’s calculated from other data) that could be managed declaratively, with the language handling the incremental updates automatically.</p>
<p>For those interested in the concept, please incr_dom <a href="https://github.com/janestreet/incremental">Incremental</a> at Jane street with follow up work <a href="https://signalsandthreads.com/building-a-ui-framework/">Bonsai</a> and , <a href="https://salsa-rs.github.io/salsa/">Salsa</a> in rust</p>
</section>
</section>
<section id="auto-backward-differentiation" class="level2">
<h2 class="anchored" data-anchor-id="auto-backward-differentiation">2. Auto Backward Differentiation</h2>
<section id="the-concept" class="level3">
<h3 class="anchored" data-anchor-id="the-concept">The Concept</h3>
<p>Automatic differentiation is a technique that calculates derivatives of functions by tracking how values change through each step of computation. In simpler terms, it automatically answers the question: “If I change input X slightly, how will that affect output Y?”</p>
<p>In machine learning, this powers gradient descent by determining how to adjust model parameters. But its potential is far broader - it enables any algorithm to understand its own sensitivity to inputs and optimize itself accordingly.</p>
<p>Libraries like PyTorch and TensorFlow allow developers to write forward computations while automatically generating the backward pass for gradients. This powerful capability should be a language-level primitive rather than confined to specialized libraries.</p>
<p>Swift has already <a href="https://github.com/swiftlang/swift/blob/main/docs/DifferentiableProgramming.md">started exploring</a> this direction with its <span class="citation" data-cites="differentiable">@differentiable</span> attribute. By making differentiation a core language feature, developers could write regular functions and automatically get their derivatives without additional work.</p>
<p>This would be extremely valuable beyond machine learning. Imagine optimizing traditional algorithms with learned components, like</p>
<ul>
<li><p><a href="https://dl.acm.org/doi/10.1145/3318464.3389752">automatically tuning the pivot selection</a> in a quicksort algorithm based on data characteristics, eg. <em>yielding an average 3.38x performance improvement over C++ STL sort</em></p></li>
<li><p><a href="https://arxiv.org/abs/1712.01208">learning better indexing structures in databases</a> , eg. <em>outperforming cache-optimized B-Trees by up to 70% in speed while saving an order-of-magnitude in memory over several real-world data sets</em></p></li>
</ul>
</section>
</section>
<section id="auto-reversibility" class="level2">
<h2 class="anchored" data-anchor-id="auto-reversibility">3. Auto Reversibility</h2>
<section id="the-idea" class="level3">
<h3 class="anchored" data-anchor-id="the-idea">The Idea</h3>
<p>When you write an encoding function, the language could automatically generate the corresponding decoding function, saving development time and reducing errors.</p>
<p>Not all encodings are reversible (mapping to a constant is lossy), but the type system should warn you about this. For composable transforms where each step is individually reversible, the language should be able to generate the reverse operation automatically.</p>
<p>This is particularly valuable in serialization scenarios where you often need to write both encoding and decoding logic. The language could warn you when an encoding scheme isn’t reversible and automatically generate the decoding code when it is. Like with auto differentiation, this would create a new class of guarantees where the language ensures round-trip conversions work correctly—something currently left to unit tests.</p>
<p>Conceptually, auto reversibility shares foundations with auto differentiation - both analyze code structure to generate new code with related but different behavior. While differentiation focuses on how outputs change when inputs change, reversibility focuses on how to get back to original inputs from outputs.</p>
<p>For composable transforms where each step is individually reversible, the language would automatically combine the individual reverse operations in the correct order. This creates powerful guarantees: data that goes through a series of transformations can always be accurately restored, something currently left to extensive testing.</p>
<p>For those interested in this topic checkout, <a href="https://web.archive.org/web/20230213042039/https://www.cs.cornell.edu/~jnfoster/papers/jnfoster-dissertation.pdf">Boomerang</a> lang, <a href="https://archive.org/details/lenses-compositional-data-access-and-manipulation-simon-peyton-jones-at-haskell-">“lens”</a> library in haskell.</p>
</section>
</section>
<section id="speculative-execution" class="level2">
<h2 class="anchored" data-anchor-id="speculative-execution">4. Speculative Execution</h2>
<section id="the-concept-1" class="level3">
<h3 class="anchored" data-anchor-id="the-concept-1">The Concept</h3>
<p>In CPU design, speculative execution transforms linear sets of instructions to parallel ones by predicting branch outcomes and executing instructions in parallel before knowing if they’re needed. This technique delivers 10x improvements in instructions executed per second by bypassing sequential bottlenecks, <a href="https://www.youtube.com/watch?v=Nb2tebYAaOA&amp;t=417s&amp;ab_channel=LexFridman">watch here</a> for Jim Keller explain this beautifully. How much we are able to parallize depends on the quality of our prediction, and it stops at I/O boundaries.</p>
<p>What if our programming languages had primitives for speculative execution at a higher level? When your program hits operations that can’t be parallelized (like waiting for user input or network calls), the runtime could predict likely outcomes and continue processing dependent code paths in parallel.</p>
<p>This would transform programming by dramatically improving perceived performance in user-facing applications, potentially reducing wait times by orders of magnitude without complex custom implementations.</p>
<p>What makes this particularly exciting now is that modern machine learning and deep learning techniques are dramatically improving our ability to predict outcomes. Where CPUs use simple branch prediction, language runtimes could leverage sophisticated ML models to predict entire datasets, user inputs, or API responses with increasing accuracy. This could transform inherently sequential programs into highly parallel ones, potentially delivering order-of-magnitude performance improvements for previously bottlenecked operations.</p>
<p>Here’s how an interface might look:</p>
<pre><code>interface executable_func {
    call() -&gt; blocks
}

interface speculative_executable_func {
    call_speculatively() -&gt; non-blocking pre-work
    cancel() 
    confirm() -&gt; potentially blocking 
}</code></pre>
<p>The key to making this secure is that speculative work should not produce visible side effects until explicitly confirmed. The “cancel” semantics are crucial—they must provide clean, reliable ways to exit speculative execution paths without external systems ever seeing the effects of canceled operations.</p>
<p>A real-world example: Instagram used to speculatively upload images before users completed their posts. Since machines are so much faster than humans, they can do significant work while a user is still making decisions.</p>
<p>Imagine a user signup form that speculatively initializes all the infrastructure needed, canceling if the user abandons the process. By the time the user completes the form, the system is already ready.</p>
</section>
</section>
<section id="external-state-management" class="level2">
<h2 class="anchored" data-anchor-id="external-state-management">5. External State Management</h2>
<section id="the-challenge" class="level3">
<h3 class="anchored" data-anchor-id="the-challenge">The Challenge</h3>
<p>Currently, program state lives inside a process’s memory. If the process dies, state must be explicitly persisted outside so it can be retried. Long-running computations, retries, and multi-process coordination require hand-crafted state machines.</p>
</section>
<section id="the-solution-1" class="level3">
<h3 class="anchored" data-anchor-id="the-solution-1">The Solution</h3>
<p>Orchestration systems like Airflow, Metaflow, and Temporal address this problem, persisting state outside the running program to survive program crashes.</p>
<p>State management could become a language-level primitive, integrating this directly into languages would make these patterns more accessible and reliable. The runtime would automatically track state and persist key checkpoints outside the process.</p>
</section>
</section>
<section id="a-unified-system" class="level2">
<h2 class="anchored" data-anchor-id="a-unified-system">A Unified System</h2>
<p>These concepts work very well together when combined. Speculative execution predicts outcomes to bypass sequential bottlenecks, but it becomes even more powerful when paired with incrementality and auto-reversibility.</p>
<p>Incrementality ensures that when predictions are wrong, we only need to recompute the specific parts affected by the misprediction rather than throwing away all speculative work. This dramatically reduces the cost of speculation errors.</p>
<p>Meanwhile, auto-reversibility provides a safety mechanism for rolling back side effects from incorrect speculations. When a prediction proves wrong, the system can automatically generate and execute reversal operations, cleanly undoing partial work without developer-written cleanup code.</p>
<p>Together, these three language features could transform how we approach performance optimization: speculative execution provides parallelism where none existed before, incrementality minimizes wasted computation when predictions fail, and auto-reversibility ensures the system remains consistent throughout. This combination would allow developers to write simple, sequential code while the language runtime automatically delivers parallel performance with graceful error handling.</p>
</section>
<section id="philosophy-and-design-challenges" class="level2">
<h2 class="anchored" data-anchor-id="philosophy-and-design-challenges">Philosophy and Design Challenges</h2>
<p>Great programming languages make it easy to describe “what” we want to achieve while providing understandable guarantees about “how” it gets achieved. Many languages today force programmers to handle both aspects, often requiring explicit control of implementation details that could instead be managed by the runtime.</p>
<p>When I talk about adding “magic” to the runtime, I acknowledge that it’s a high bar to cross.</p>
<p>Developers often fall back to more “understandable” approaches when things aren’t done well. But this doesn’t need to be the default state. Consider how most programmers don’t think about the fact that their code gets pipelined, executed out of order, and speculatively executed on CPU hardware—because this is done extremely well at the hardware level.</p>
<p>The hardware provides an ‘<strong>imperative illusion</strong>’: programmers write sequential code, but the CPU executes it differently while rigorously upholding a contract (the ISA) that guarantees the observable results match the sequential model. Because this contract is reliable, developers trust the abstraction. I believe similar abstractions can work at the programming language runtime level too, allowing developers to write straightforward code while the runtime performs complex optimizations transparently, provided its behavioral contract is equally strong.</p>
<p>That said, these new features introduce several challenges:</p>
<ul>
<li><p><strong>Predictability vs.&nbsp;Optimization</strong>: If the language/runtime contractual promises aren’t kept, developers end up “fighting the compiler” rather than benefiting from its intelligence. This is similar to what Horace He describes with compiler optimizations—when they don’t work as expected, users are forced to understand implementation details they shouldn’t need to care about.</p></li>
<li><p><strong>Control vs.&nbsp;Convenience</strong>: The key insight is that a good programming model provides guarantees users can rely on. Rather than adding compiler magic that sometimes works, we should design programming models where the optimizations are part of the contract with users. For example, with speculative execution, we need clear semantics around cancellation to ensure side effects remain invisible until confirmed.</p></li>
<li><p><strong>Debugging Complexity</strong>: When things go wrong with magic features, higher levels of abstraction can make it harder to understand what happened. Users need clear mental models and tools to reason about behavior.</p></li>
<li><p><strong>Performance Characteristics</strong>: These features may introduce overhead or unpredictable performance profiles that make systems harder to reason about. A successful approach would make performance characteristics part of the programming model.</p></li>
</ul>
<p>The success of speculative execution in CPUs suggests these techniques are broadly useful. The challenge isn’t whether these optimizations are possible, but how to expose them through programming models that give users reliable guarantees based on a clear contract, without forcing them to understand implementation details.</p>
</section>
<section id="conclusion" class="level2">
<h2 class="anchored" data-anchor-id="conclusion">Conclusion</h2>
<p>There are many more interesting directions to explore in programming language design beyond what I’ve outlined here. The ideas in this post represent just a few of the possibilities that excite me. I look forward to seeing how the programming language landscape evolves as researchers and language designers continue to push the boundaries of what’s possible, making programming both more powerful, accessible, and performant.</p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const disableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'prefetch';
    }
  }
  const enableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'stylesheet';
    }
  }
  const manageTransitions = (selector, allowTransitions) => {
    const els = window.document.querySelectorAll(selector);
    for (let i=0; i < els.length; i++) {
      const el = els[i];
      if (allowTransitions) {
        el.classList.remove('notransition');
      } else {
        el.classList.add('notransition');
      }
    }
  }
  const toggleGiscusIfUsed = (isAlternate, darkModeDefault) => {
    const baseTheme = document.querySelector('#giscus-base-theme')?.value ?? 'light';
    const alternateTheme = document.querySelector('#giscus-alt-theme')?.value ?? 'dark';
    let newTheme = '';
    if(darkModeDefault) {
      newTheme = isAlternate ? baseTheme : alternateTheme;
    } else {
      newTheme = isAlternate ? alternateTheme : baseTheme;
    }
    const changeGiscusTheme = () => {
      // From: https://github.com/giscus/giscus/issues/336
      const sendMessage = (message) => {
        const iframe = document.querySelector('iframe.giscus-frame');
        if (!iframe) return;
        iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app');
      }
      sendMessage({
        setConfig: {
          theme: newTheme
        }
      });
    }
    const isGiscussLoaded = window.document.querySelector('iframe.giscus-frame') !== null;
    if (isGiscussLoaded) {
      changeGiscusTheme();
    }
  }
  const toggleColorMode = (alternate) => {
    // Switch the stylesheets
    const alternateStylesheets = window.document.querySelectorAll('link.quarto-color-scheme.quarto-color-alternate');
    manageTransitions('#quarto-margin-sidebar .nav-link', false);
    if (alternate) {
      enableStylesheet(alternateStylesheets);
      for (const sheetNode of alternateStylesheets) {
        if (sheetNode.id === "quarto-bootstrap") {
          toggleBodyColorMode(sheetNode);
        }
      }
    } else {
      disableStylesheet(alternateStylesheets);
      toggleBodyColorPrimary();
    }
    manageTransitions('#quarto-margin-sidebar .nav-link', true);
    // Switch the toggles
    const toggles = window.document.querySelectorAll('.quarto-color-scheme-toggle');
    for (let i=0; i < toggles.length; i++) {
      const toggle = toggles[i];
      if (toggle) {
        if (alternate) {
          toggle.classList.add("alternate");     
        } else {
          toggle.classList.remove("alternate");
        }
      }
    }
    // Hack to workaround the fact that safari doesn't
    // properly recolor the scrollbar when toggling (#1455)
    if (navigator.userAgent.indexOf('Safari') > 0 && navigator.userAgent.indexOf('Chrome') == -1) {
      manageTransitions("body", false);
      window.scrollTo(0, 1);
      setTimeout(() => {
        window.scrollTo(0, 0);
        manageTransitions("body", true);
      }, 40);  
    }
  }
  const isFileUrl = () => { 
    return window.location.protocol === 'file:';
  }
  const hasAlternateSentinel = () => {  
    let styleSentinel = getColorSchemeSentinel();
    if (styleSentinel !== null) {
      return styleSentinel === "alternate";
    } else {
      return false;
    }
  }
  const setStyleSentinel = (alternate) => {
    const value = alternate ? "alternate" : "default";
    if (!isFileUrl()) {
      window.localStorage.setItem("quarto-color-scheme", value);
    } else {
      localAlternateSentinel = value;
    }
  }
  const getColorSchemeSentinel = () => {
    if (!isFileUrl()) {
      const storageValue = window.localStorage.getItem("quarto-color-scheme");
      return storageValue != null ? storageValue : localAlternateSentinel;
    } else {
      return localAlternateSentinel;
    }
  }
  const darkModeDefault = false;
  let localAlternateSentinel = darkModeDefault ? 'alternate' : 'default';
  // Dark / light mode switch
  window.quartoToggleColorScheme = () => {
    // Read the current dark / light value 
    let toAlternate = !hasAlternateSentinel();
    toggleColorMode(toAlternate);
    setStyleSentinel(toAlternate);
    toggleGiscusIfUsed(toAlternate, darkModeDefault);
  };
  // Ensure there is a toggle, if there isn't float one in the top right
  if (window.document.querySelector('.quarto-color-scheme-toggle') === null) {
    const a = window.document.createElement('a');
    a.classList.add('top-right');
    a.classList.add('quarto-color-scheme-toggle');
    a.href = "";
    a.onclick = function() { try { window.quartoToggleColorScheme(); } catch {} return false; };
    const i = window.document.createElement("i");
    i.classList.add('bi');
    a.appendChild(i);
    window.document.body.appendChild(a);
  }
  // Switch to dark mode if need be
  if (hasAlternateSentinel()) {
    toggleColorMode(true);
  } else {
    toggleColorMode(false);
  }
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp("https:\/\/www\.arjunsriva\.com");
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>